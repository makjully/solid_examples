Идея: предоставление каждому клиенту минимального (в идеале - отдельного) интерфейса.

Проблема: используя интерфейс Bird в "плохом" примере, наследующие его классы получат ненужные методы (более того -
методы, которые они не умеют исполнять).

Решение: при декомпозиции и использовании более конкретных типов (Swimmable, Runnable, Flying, Speakable)
имплементирующие их классы будут обладать набором только необходимых и характеризующих их методов.