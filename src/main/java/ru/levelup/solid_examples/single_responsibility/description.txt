Идея: каждый класс должен решать лишь одну задачу. У класса должна быть только одна причина для изменения.

Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы,
реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к
изменениям в другой.

Пример: у нас есть класс EmployeeStore, который умеет искать / добавлять сотрудников и отправлять им письма. Допустим,
что появилось новое требование: письма могут быть текстовые или в формате HTML. Вроде бы ничего невыполнимого - можно
добавить метод sendHtmlEmail(), что просто сделает класс более нагруженным и вызовет неопределенность в использовании
нужного метода для отправки письма.

Решение: интерфейсы EmailSender (ответственен только за отправку письма) и EmailContent (ответственен за тип и
содержание письма). Теперь все, что касается логики отправки писем, фиксится и дополняется только в EmailSender. Что
относится к CRUD-операциям для работников, сосредоточено в EmployeeStore (только это является его зоной ответственности).